### 1. LIMPIEZA DE DATOS
# Importar datos de PIB y CO2 ------------------------------------
pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")
data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
data_co2 <- read_excel(co2_file, sheet = "Data", skip = 3) %>% clean_names()
# Seleccionar columnas de interés para 2023 ---------------------
pib_2023 <- data_pib %>%
select(country_code, pib_2023 = x2023)
co2_2023 <- data_co2 %>%
select(country_code, co2_2023 = x2023)
# Integrar datasets por código de país -------------------------
data_join <- left_join(pib_2023, co2_2023, by = "country_code") %>%
drop_na()
# Clasificación: Alto vs. Bajo PIB -----------------------------
data_join <- data_join %>%
mutate(grupo_pib = if_else(
pib_2023 >= median(pib_2023, na.rm = TRUE),
"Alto PIB per cápita",
"Bajo PIB per cápita"
))
# Separando los DF --------------------------------------------
d1 <- data_join %>% filter(grupo_pib=="Alto PIB per cápita")
d2 <- data_join %>% filter(grupo_pib=="Bajo PIB per cápita")
View(d1)
# 2️⃣ Diferencia promedio
dif_media <- mean(d1$co2_2023, na.rm = TRUE) - mean(d2$co2_2023, na.rm = TRUE)
cat("Diferencia promedio de emisiones (PIB alto - PIB bajo):",
round(dif_media, 3), "\n")
# 3️⃣ Prueba t clásica
t_test_res <- t.test(co2_2023 ~ grupo_pib, data = data_join, var.equal = FALSE)
cat("Resultados de la prueba t:\n",
"Media PIB alto:", round(t_test_res$estimate[1], 3), "\n",
"Media PIB bajo:", round(t_test_res$estimate[2], 3), "\n",
"Diferencia de medias:", round(t_test_res$estimate[1] - t_test_res$estimate[2], 3), "\n",
"p-valor:", round(t_test_res$p.value, 4), "\n")
### 3. DIFERENCIA PROMEDIO
set.seed(1234)   # reproducibilidad
# 2️⃣ Diferencia promedio
dif_media <- mean(d1$co2_2023, na.rm = TRUE) - mean(d2$co2_2023, na.rm = TRUE)
cat("Diferencia promedio de emisiones (PIB alto - PIB bajo):",
round(dif_media, 3), "\n")
# 3️⃣ Prueba t clásica
t_test_res <- t.test(co2_2023 ~ grupo_pib, data = data_join, var.equal = FALSE)
cat("Resultados de la prueba t:\n",
"Media PIB alto:", round(t_test_res$estimate[1], 3), "\n",
"Media PIB bajo:", round(t_test_res$estimate[2], 3), "\n",
"Diferencia de medias:", round(t_test_res$estimate[1] - t_test_res$estimate[2], 3), "\n",
"p-valor:", round(t_test_res$p.value, 4), "\n")
# ============================================================
# Paso 1. Función de media para bootstrap
# ============================================================
boot_mean <- function(data, indices) {
d <- data[indices, ]
mean(d$co2_2023)                  # ya no verificamos NA
}
# ============================================================
# Paso 2. Función que devuelve media y ambos IC95% (BCa y Percentil)
# ============================================================
summarize_boot_both <- function(df, etiqueta, R = 10000, seed = 123){
set.seed(seed)
b  <- boot::boot(df, statistic = boot_mean, R = R)
ci <- boot::boot.ci(b, type = c("bca", "perc"))
# Extraer ambos IC (si alguno no se puede calcular, queda NA)
lwr_bca <- if (!is.null(ci$bca))    ci$bca[4]    else NA_real_
upr_bca <- if (!is.null(ci$bca))    ci$bca[5]    else NA_real_
lwr_per <- if (!is.null(ci$percent)) ci$percent[4] else NA_real_
upr_per <- if (!is.null(ci$percent)) ci$percent[5] else NA_real_
tibble::tibble(
grupo_pib      = etiqueta,
n_paises       = nrow(df),
mean_co2       = mean(df$co2_2023),
boot_R         = R,
ic95_low_bca   = lwr_bca,
ic95_high_bca  = upr_bca,
ic95_low_perc  = lwr_per,
ic95_high_perc = upr_per
)
}
# ============================================================
# Paso 3. Aplicar a cada grupo (Alto / Bajo PIB) y redondear
# ============================================================
tabla_ic_wide <- dplyr::bind_rows(
summarize_boot_both(d1, "Alto PIB per cápita"),
summarize_boot_both(d2, "Bajo PIB per cápita")
) %>%
dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ round(.x, 3)))
print(tabla_ic_wide)
View(d1)
View(d2)
# 2️⃣ Diferencia promedio
dif_media <- mean(d1$co2_2023, na.rm = TRUE) - mean(d2$co2_2023, na.rm = TRUE)
cat("Diferencia promedio de emisiones (PIB alto - PIB bajo):",
round(dif_media, 3), "\n")
# 3️⃣ Prueba t clásica
t_test_res <- t.test(co2_2023 ~ grupo_pib, data = data_join, var.equal = FALSE)
cat("Resultados de la prueba t:\n",
"Media PIB alto:", round(t_test_res$estimate[1], 3), "\n",
"Media PIB bajo:", round(t_test_res$estimate[2], 3), "\n",
"Diferencia de medias:", round(t_test_res$estimate[1] - t_test_res$estimate[2], 3), "\n",
"p-valor:", round(t_test_res$p.value, 4), "\n")
set.seed(1234)
# ============================================================
# Paso 1. Función bootstrap: diferencia de medias entre grupos
# ============================================================
boot_diff <- function(data, indices) {
d <- data[indices, ]
mean(d$co2_2023[d$grupo_pib == "Alto"], na.rm = TRUE) -
mean(d$co2_2023[d$grupo_pib == "Bajo"], na.rm = TRUE)
}
# ============================================================
# Paso 2. Calcular bootstrap para la diferencia
# ============================================================
boot_diff_res <- boot::boot(data_join, statistic = boot_diff, R = 10000)
# IC 95% (percentil y BCa)
ci_diff <- boot::boot.ci(boot_diff_res, type = c("perc", "bca"))
### 3. DIFERENCIA PROMEDIO
# Diferencia promedio
dif_media <- mean(d1$co2_2023, na.rm = TRUE) - mean(d2$co2_2023, na.rm = TRUE)
cat("Diferencia promedio de emisiones (PIB alto - PIB bajo):",
round(dif_media, 3), "\n")
# ============================================================
# Paso 1. Función de media para bootstrap (por grupo)
# ============================================================
boot_mean <- function(data, indices) {
d <- data[indices, ]
mean(d$co2_2023)
}
# ============================================================
# Paso 2. Función que devuelve media e IC95% (BCa y Percentil)
# ============================================================
summarize_boot_both <- function(df, etiqueta, R = 10000, seed = 123){
set.seed(seed)
b  <- boot::boot(df, statistic = boot_mean, R = R)
ci <- boot::boot.ci(b, type = c("bca", "perc"))
# Extraer ambos IC (si alguno no se puede calcular, queda NA)
lwr_bca <- if (!is.null(ci$bca))    ci$bca[4]    else NA_real_
upr_bca <- if (!is.null(ci$bca))    ci$bca[5]    else NA_real_
lwr_per <- if (!is.null(ci$percent)) ci$percent[4] else NA_real_
upr_per <- if (!is.null(ci$percent)) ci$percent[5] else NA_real_
tibble::tibble(
grupo_pib      = etiqueta,
n_paises       = nrow(df),
mean_co2       = mean(df$co2_2023),
boot_R         = R,
ic95_low_bca   = lwr_bca,
ic95_high_bca  = upr_bca,
ic95_low_perc  = lwr_per,
ic95_high_perc = upr_per
)
}
# ============================================================
# Paso 3. Aplicar a cada grupo (Alto / Bajo PIB)
# ============================================================
tabla_ic_wide <- dplyr::bind_rows(
summarize_boot_both(d1, "Alto PIB per cápita"),
summarize_boot_both(d2, "Bajo PIB per cápita")
) %>%
dplyr::mutate(dplyr::across(dplyr::where(is.numeric), ~ round(.x, 3)))
print(tabla_ic_wide)
# ============================================================
# Paso 4. Bootstrap de la DIFERENCIA de medias
# ============================================================
boot_diff <- function(data, indices) {
d <- data[indices, ]
mean(d$co2_2023[d$grupo_pib == "Alto"], na.rm = TRUE) -
mean(d$co2_2023[d$grupo_pib == "Bajo"], na.rm = TRUE)
}
boot_diff_res <- boot::boot(data_join, statistic = boot_diff, R = 10000)
ci_diff <- boot::boot.ci(boot_diff_res, type = c("bca", "perc"))
### 3. DIFERENCIA PROMEDIO
# ============================================================
# Paso 0. Diferencia promedio simple
# ============================================================
dif_media <- mean(d1$co2_2023, na.rm = TRUE) - mean(d2$co2_2023, na.rm = TRUE)
cat("Diferencia promedio de emisiones (PIB alto - PIB bajo):",
round(dif_media, 3), "\n")
# ============================================================
# Paso 1. Función de media para bootstrap (por grupo)
# ============================================================
boot_mean <- function(data, indices) {
d <- data[indices, ]
mean(d$co2_2023, na.rm = TRUE)
}
# ============================================================
# Paso 2. Función que devuelve media e IC95% (BCa y Percentil)
# ============================================================
summarize_boot_both <- function(df, etiqueta, R = 10000, seed = 123){
set.seed(seed)
b  <- boot::boot(df, statistic = boot_mean, R = R)
ci <- boot::boot.ci(b, type = c("bca", "perc"))
tibble::tibble(
grupo_pib      = etiqueta,
n_paises       = nrow(df),
mean_co2       = mean(df$co2_2023, na.rm = TRUE),
boot_R         = R,
ic95_low_bca   = ifelse(!is.null(ci$bca), ci$bca[4], NA_real_),
ic95_high_bca  = ifelse(!is.null(ci$bca), ci$bca[5], NA_real_),
ic95_low_perc  = ifelse(!is.null(ci$percent), ci$percent[4], NA_real_),
ic95_high_perc = ifelse(!is.null(ci$percent), ci$percent[5], NA_real_)
)
}
# ============================================================
# Paso 3. Aplicar a cada grupo (Alto / Bajo PIB)
# ============================================================
tabla_ic_wide <- dplyr::bind_rows(
summarize_boot_both(d1, "Alto PIB per cápita"),
summarize_boot_both(d2, "Bajo PIB per cápita")
) %>%
dplyr::mutate(across(where(is.numeric), ~ round(.x, 3)))
print(tabla_ic_wide)
# ============================================================
# Paso 4. Bootstrap de la DIFERENCIA de medias
# ============================================================
boot_diff <- function(data, indices) {
d <- data[indices, ]
mean(d$co2_2023[d$grupo_pib == "Alto PIB per cápita"], na.rm = TRUE) -
mean(d$co2_2023[d$grupo_pib == "Bajo PIB per cápita"], na.rm = TRUE)
}
set.seed(123)
boot_diff_res <- boot::boot(data_join, statistic = boot_diff, R = 10000)
ci_diff <- boot::boot.ci(boot_diff_res, type = c("bca", "perc"))
cat("\n=== Bootstrap diferencia de medias (Alto - Bajo PIB) ===\n")
cat("Diferencia promedio:", round(mean(boot_diff_res$t), 3), "\n")
cat("IC95% Percentil:", round(ci_diff$percent[4], 3), "a", round(ci_diff$percent[5], 3), "\n")
cat("IC95% BCa:", round(ci_diff$bca[4], 3), "a", round(ci_diff$bca[5], 3), "\n\n")
# ============================================================
# Paso 5. Prueba t clásica para comparación
# ============================================================
t_test_res <- t.test(co2_2023 ~ grupo_pib, data = data_join, var.equal = FALSE)
cat("=== Prueba t clásica ===\n")
cat("Media PIB alto:", round(t_test_res$estimate[1], 3), "\n")
cat("Media PIB bajo:", round(t_test_res$estimate[2], 3), "\n")
cat("Diferencia de medias:", round(t_test_res$estimate[1] - t_test_res$estimate[2], 3), "\n")
cat("IC95%:", round(t_test_res$conf.int[1], 3), "a", round(t_test_res$conf.int[2], 3), "\n")
cat("p-valor:", round(t_test_res$p.value, 4), "\n")
# Gráfico de distribución bootstrap
tibble(diff = b_diff$t) %>%
ggplot(aes(x = diff)) +
geom_histogram(aes(y = ..density..), bins = 50, fill = "skyblue", alpha = 0.6) +
geom_density(color = "blue", size = 1) +
geom_vline(xintercept = mean(b_diff$t), color = "black", size = 1.2) +
geom_vline(xintercept = c(lwr_perc, upr_perc), color = "red", linetype = "dashed", size = 1) +
geom_vline(xintercept = c(lwr_bca, upr_bca), color = "green", linetype = "dashed", size = 1) +
labs(
title = "Distribución bootstrap de la diferencia de emisiones (Alto - Bajo PIB)",
subtitle = "Líneas: negro = media, rojo = IC95% percentil, verde = IC95% BCa",
x = "Diferencia de medias de CO₂ per cápita",
y = "Densidad"
) +
theme_minimal(base_size = 13)
# Gráfico de distribución bootstrap
ggplot(data = tibble(diff = boot_diff_res$t), aes(x = diff)) +
geom_histogram(aes(y = ..density..), bins = 50, fill = "skyblue", alpha = 0.6) +
geom_density(color = "blue", size = 1) +
geom_vline(xintercept = mean(boot_diff_res$t), color = "black", size = 1.2) +
geom_vline(xintercept = c(ci_diff$percent[4], ci_diff$percent[5]), color = "red", linetype = "dashed", size = 1) +
geom_vline(xintercept = c(ci_diff$bca[4], ci_diff$bca[5]), color = "green", linetype = "dashed", size = 1) +
labs(
title = "Distribución bootstrap de la diferencia de emisiones (PIB alto - PIB bajo)",
subtitle = "Líneas: negro = media | rojo = IC95% Percentil | verde = IC95% BCa",
x = "Diferencia de medias de CO₂ per cápita",
y = "Densidad"
) +
theme_minimal(base_size = 13)
_boot <- ggplot(data = tibble(diff = boot_diff_res$t), aes(x = diff)) +
# Gráfico de distribución bootstrap
g4 <- ggplot(data = tibble(diff = boot_diff_res$t), aes(x = diff)) +
geom_histogram(aes(y = ..density..), bins = 50, fill = "#5B8FA8", alpha = 0.6, color = "white") +
geom_density(color = "#003366", size = 1.2) +
geom_vline(xintercept = mean(boot_diff_res$t), color = "#003366", size = 1.3) +
geom_vline(xintercept = c(ci_diff$percent[4], ci_diff$percent[5]), color = "#1B4F72", linetype = "dashed", size = 1) +
geom_vline(xintercept = c(ci_diff$bca[4], ci_diff$bca[5]), color = "#2874A6", linetype = "dotted", size = 1) +
labs(
title = "Distribución bootstrap de la diferencia de emisiones (PIB alto - PIB bajo)",
subtitle = "Líneas: azul oscuro = media | guiones = IC95% Percentil | puntos = IC95% BCa",
x = "Diferencia de medias de CO₂ per cápita",
y = "Densidad"
) +
theme_minimal(base_size = 13, base_family = "Helvetica") +
theme(
panel.grid = element_blank(),
plot.title = element_text(face = "bold", color = "#003366", size = 14),
plot.subtitle = element_text(color = "#1B4F72", size = 11),
axis.title = element_text(face = "bold", color = "#003366"),
axis.text = element_text(color = "gray20")
)
print(g4)
# ============================================================
# Guardar gráfico
# ============================================================
ggsave("Graficos/g4.png", g4, width = 8, height = 6, dpi = 300)
# Gráfico de distribución bootstrap
g4 <- ggplot(data = tibble(diff = boot_diff_res$t), aes(x = diff)) +
geom_histogram(aes(y = ..density..), bins = 50, fill = "#5B8FA8", alpha = 0.6, color = "white") +
geom_density(color = "#003366", size = 1.2) +
geom_vline(xintercept = mean(boot_diff_res$t), color = "#003366", size = 1.3) +
geom_vline(xintercept = c(ci_diff$percent[4], ci_diff$percent[5]), color = "#1B4F72", linetype = "dashed", size = 1) +
geom_vline(xintercept = c(ci_diff$bca[4], ci_diff$bca[5]), color = "#2874A6", linetype = "dotted", size = 1) +
labs(
title = "Distribución de la diferencia de emisiones(PIB alto - PIB bajo)",
subtitle = "Líneas: azul oscuro = media | guiones = IC95% Percentil | puntos = IC95% BCa",
x = "Diferencia de medias de CO2 per cápita",
y = "Densidad"
) +
theme_minimal(base_size = 13, base_family = "Helvetica") +
theme(
panel.grid = element_blank(),
plot.title = element_text(face = "bold", color = "#003366", size = 14),
plot.subtitle = element_text(color = "#1B4F72", size = 11),
axis.title = element_text(face = "bold", color = "#003366"),
axis.text = element_text(color = "gray20")
)
ggsave("Graficos/g4.png", g4, width = 8, height = 6, dpi = 300)
g4
# Gráfico de distribución bootstrap
g4 <- ggplot(data = tibble(diff = boot_diff_res$t), aes(x = diff)) +
geom_histogram(aes(y = ..density..), bins = 50, fill = "#5B8FA8", alpha = 0.6, color = "white") +
geom_density(color = "#003366", size = 1.2) +
geom_vline(xintercept = mean(boot_diff_res$t), color = "#003366", size = 1.3) +
geom_vline(xintercept = c(ci_diff$percent[4], ci_diff$percent[5]), color = "#1B4F72", linetype = "dashed", size = 1) +
geom_vline(xintercept = c(ci_diff$bca[4], ci_diff$bca[5]), color = "#2874A6", linetype = "dotted", size = 1) +
labs(
title = "Distribución de la diferencia de emisiones(PIB alto - PIB bajo)",
x = "Diferencia de medias de CO2 per cápita",
y = "Densidad"
) +
theme_minimal(base_size = 13, base_family = "Helvetica") +
theme(
panel.grid = element_blank(),
plot.title = element_text(face = "bold", color = "#003366", size = 14),
plot.subtitle = element_text(color = "#1B4F72", size = 11),
axis.title = element_text(face = "bold", color = "#003366"),
axis.text = element_text(color = "gray20")
)
ggsave("Graficos/g4.png", g4, width = 8, height = 6, dpi = 300)
g4
# 1️⃣ Verificar si el intervalo bootstrap incluye el 0
ic_low <- ci_diff$bca[4]
ic_high <- ci_diff$bca[5]
incluye_cero <- (ic_low <= 0 & ic_high >= 0)
cat("¿El IC95% bootstrap incluye el valor 0?:", incluye_cero, "\n")
cat("IC95% BCa =", round(ic_low, 3), "a", round(ic_high, 3), "\n\n")
# Verificar si el intervalo bootstrap incluye el 0
ic_low <- ci_diff$bca[4]
ic_high <- ci_diff$bca[5]
incluye_cero <- (ic_low <= 0 & ic_high >= 0)
cat("¿El IC95% bootstrap incluye el valor 0?:", incluye_cero, "\n")
cat("IC95% BCa =", round(ic_low, 3), "a", round(ic_high, 3), "\n\n")
# 2️⃣ Obtener p-valor de la prueba t
p_valor <- t_test_res$p.value
cat("p-valor de la prueba t:", round(p_valor, 5), "\n")
if (p_valor < 0.05) {
cat("→ Se rechaza H0 al 5% de significancia. Evidencia de diferencia significativa.\n")
} else {
cat("→ No se rechaza H0 al 5%. No hay evidencia de diferencia significativa.\n")
}
if (!incluye_cero & p_valor < 0.05) {
cat("\n✅ Ambos métodos (Bootstrap y prueba t) llevan a la misma conclusión: \n")
cat("   los países de PIB alto emiten significativamente más CO₂ per cápita.\n")
} else {
cat("\n⚠️ Los resultados no son completamente consistentes entre métodos.\n")
}
#  Obtener p-valor de la prueba t
p_valor <- t_test_res$p.value
cat("p-valor de la prueba t:", format(p_valor, scientific = TRUE, digits = 5), "\n")
if (p_valor < 0.05) {
cat("→ Se rechaza H0 al 5% de significancia. Evidencia de diferencia significativa.\n")
} else {
cat("→ No se rechaza H0 al 5%. No hay evidencia de diferencia significativa.\n")
}
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")
# Cargando los paquetes usando pacman
pacman::p_load(
# A) Manipulación, limpieza y visualización de datos
tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr,        # Generación de reportes dinámicos.
ggrepel,
ggpar,
)
# Instalando pacman si se requier
if (!require("pacman")) install.packages("pacman")
# Cargando los paquetes usando pacman
pacman::p_load(
# A) Manipulación, limpieza y visualización de datos
tidyverse,    # Colección de paquetes esenciales (incluye dplyr, ggplot2, etc.)
forcats,      # Herramientas para trabajar con variables categóricas (factores).
tibble,       # Implementación moderna de data.frames.
janitor,      # Limpieza de nombres de variables y tablas de frecuencia.
lubridate,    # Manejo avanzado de fechas y horas.
skimr,        # Resúmenes estadísticos completos y rápidos de data.frames.
stringi,      # Manipulación robusta de texto (strings).
scales,       # Formato de escalas en ggplot2 (ej. porcentajes, comas).
openxlsx,     # Guardar excel
writexl,      # Guardar excel
# B) Modelado y análisis estadístico/econométrico
fixest,       # Estimación de modelos de efectos fijos de alto rendimiento.
plm,          # Modelos econométricos para datos de panel.
AER,          # Herramientas para econometría aplicada (ej. variables instrumentales).
lmtest,       # Pruebas de hipótesis para modelos de regresión (ej. coeftest).
sandwich,     # Cálculo de errores estándar robustos a heterocedasticidad.
survey,       # Análisis de datos de encuestas complejas (ponderación, estratificación).
# C) Importación, exportación y generación de reportes
haven,        # Lectura y escritura de formatos de Stata, SAS y SPSS.
readxl,       # Lectura de archivos de Excel (.xls y .xlsx).
stargazer,    # Creación de tablas de regresión con formato de publicación.
knitr,        # Generación de reportes dinámicos.
kableExtra,
webshot,
)
### 1. LIMPIEZA DE DATOS
# Definir carpeta de datos (ruta relativa)
path <- file.path(getwd(), "datos")
# Importar datos de PIB y CO2
pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")
data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
# Definir carpeta de datos (ruta relativa)
path <- file.path(getwd(), "datos")
# Importar datos de PIB y CO2
pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")
data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
data_co2 <- read_excel(co2_file, sheet = "Data", skip = 3) %>% clean_names()
getwd()
knitr::opts_chunk$set(
echo = FALSE,
message = FALSE,
warning = FALSE
)
knitr::opts_knit$set(root.dir = "C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Big Data y Machine Learning/Repositorios/BD_ML_taller_1/StoryTelling3")
# Definir carpeta de datos (ruta relativa)
path <- file.path(getwd(), "datos")
knitr::opts_knit$set(root.dir = "C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Big Data y Machine Learning/Repositorios/BD_ML_taller_1/StoryTelling3")
# Importar datos de PIB y CO2
pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")
data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
setwd(C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Big Data y Machine Learning/Repositorios/BD_ML_taller_1/StoryTelling3)
setwd()
setwd("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Big Data y Machine Learning/Repositorios/BD_ML_taller_1/StoryTelling3")
# Importar datos de PIB y CO2
pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")
data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
path <- file.path(setwd("C:/Users/mc-c2/OneDrive - Universidad de los andes/Universidad/MECA/Big Data y Machine Learning/Repositorios/BD_ML_taller_1/StoryTelling3"), "Datos")
# Importar datos de PIB y CO2
pib_file <- file.path(path, "PIB.xls")
co2_file <- file.path(path, "CO2.xls")
data_pib <- read_excel(pib_file, sheet = "Data", skip = 3) %>% clean_names()
data_co2 <- read_excel(co2_file, sheet = "Data", skip = 3) %>% clean_names()
# Seleccionar columnas de interés para 2023
pib_2023 <- data_pib %>%
select(country_code, pib_2023 = x2023)
co2_2023 <- data_co2 %>%
select(country_code, co2_2023 = x2023)
# Integrar datasets por código de país
data_join <- left_join(pib_2023, co2_2023, by = "country_code") %>%
drop_na()
# Clasificación: Alto vs. Bajo PIB
data_join <- data_join %>%
mutate(grupo_pib = if_else(
pib_2023 >= median(pib_2023, na.rm = TRUE),
"Alto PIB per cápita",
"Bajo PIB per cápita"
))
# Separando los DF
d1 <- data_join %>% filter(grupo_pib=="Alto PIB per cápita")
d2 <- data_join %>% filter(grupo_pib=="Bajo PIB per cápita")
### 2. ANALISIS UNIVARIADO Y ESTADÍSTICAS
# Resumen descriptivo- Tabla     ----------------------------------
analisis_univariado <- data_join %>%
summarise(
`Número de países` = n_distinct(country_code),
`Año de referencia` = 2023,
`PIB mínimo` = min(pib_2023, na.rm = TRUE),
`PIB máximo` = max(pib_2023, na.rm = TRUE),
`CO₂ mínimo` = min(co2_2023, na.rm = TRUE),
`CO₂ máximo` = max(co2_2023, na.rm = TRUE)
) %>%
pivot_longer(everything(),
names_to = "Indicador",
values_to = "Valor")
# Ver tabla
analisis_univariado %>%
kbl(caption = "Tabla 1. Resumen descriptivo de PIB y CO₂ per cápita (2023)",
align = "lc",
booktabs = TRUE,
digits = 2) %>%
kable_classic(full_width = FALSE, html_font = "Times New Roman") %>%
save_kable("graficos/analisis_univariado.html")
